#!/usr/bin/env ruby
require_relative "./common/repo"
require_relative "./common/mapdb"
require_relative "./common/dry-run"

dirty = Dry.x(%[git status --porcelain], "").strip.split("\n")
  .select {|pending| pending.split("\s").last.start_with?("maps/") }
  .size > 0

fail "maps/ has pending changes, please clean them up before proposing new changes" if dirty and not Opts.force

Dry.x(%[git pull origin master]) unless ENV["CI"] or dirty

Repo.download_mapdb() unless Opts["no-download"]
MapDB.import_mapdb()
Repo.lock_with_checksum()
now = Time.now.utc.to_s
checksum = File.read("checksum")

exit if Opts["no-commit"]

changed_map_files = %x[git status --porcelain]
  .strip.split("\n").map {|change| change.split(" ").last}
  .grep(%r[^maps/gsiv])
changed_rooms        = changed_map_files.grep(%r[\.json$])
changed_string_procs = changed_map_files.grep(%r[\.rb$])

if changed_rooms.empty? && changed_string_procs.empty?
  Dry.log Color.yellow "no changes detected", label: 
  exit
end

Dry.x(%[git checkout -b chore/#{checksum}])

unless changed_rooms.empty?
  Dry.x(%[git add #{rooms.join(" ")}])
  Dry.x(%[git commit -m "chore(rooms): #{now}"])
  Dry.log Color.green "commited #{changed_rooms.size} room changes"
end

unless changed_string_procs.empty?
  Dry.x(%[git add #{changed_string_procs.join(" ")}])
  Dry.x(%[git commit -m "chore(string-procs): #{now}"])
  Dry.log Color.green "commited #{changed_rooms.size} room changes"
end

Dry.x(%[git add checksum])
Dry.x(%[git commit -m "chore(checksum): #{checksum}"])
Dry.x(%[git push origin chore/#{checksum} --tags])
Dry.x(%[git checkout master])

if Opts["dry-run"]
  # reset known tracked files
  %x[git checkout -- maps/]
  %x[git checkout -- checksum]
  # remove untracked files
  %x[git clean -f]
  Dry.log("reset maps/ to HEAD")
end