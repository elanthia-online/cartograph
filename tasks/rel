#!/usr/bin/env ruby
def dry_runnable_x(cmd, dry_run = nil)
  if Opts["dry-run"]
    Log.out(cmd.slice(0...100) + (cmd.size > 100 ? "...[truncated]" : ""), label: "dry-run")
    return dry_run
  end
  %x[#{cmd}]
end

def log(t)
  Log.out(t, label: Opts["dry-run"] ? "dry-run" : "sync")
end

require_relative "./common/repo"
require_relative "./common/mapdb"

unless dry_runnable_x(%[git status --porcelain], "").strip.split("\n").empty?
  fail "git status is dirty, please cleanup your working directory" unless Opts.force
end

dry_runnable_x(%[git pull origin master]) unless ENV["CI"]

Repo.download_mapdb()
MapDB.import_mapdb()
Repo.lock_with_checksum()
now = Time.now.utc.to_s
checksum = File.read("checksum")

exit if Opts["no-commit"]

changed_map_files = %x[git status --porcelain]
  .strip.split("\n").map {|change| change.split(" ").last}
  .grep(%r[^maps/gsiv])
changed_rooms        = changed_map_files.grep(%r[\.json$])
changed_string_procs = changed_map_files.grep(%r[\.rb$])

if changed_rooms.empty? && changed_string_procs.empty?
  log Color.yellow "no changes detected", label: 
  exit
end

dry_runnable_x(%[git checkout -b chore/#{checksum}])

unless changed_rooms.empty?
  changed_rooms.each {|room| dry_runnable_x(%[git add #{room}]) }
  dry_runnable_x(%[git commit -m "chore(rooms): #{now}"])
  log Color.green "commited #{changed_rooms.size} room changes"
end

unless changed_string_procs.empty?
  dry_runnable_x(%[git add #{changed_string_procs.join(" ")}])
  dry_runnable_x(%[git commit -m "chore(string-procs): #{now}"])
  log Color.green "commited #{changed_rooms.size} room changes"
end

dry_runnable_x(%[git add checksum])
dry_runnable_x(%[git commit -m "chore(checksum): #{checksum}"])
dry_runnable_x(%[git tag map.gsiv.#{checksum}])
dry_runnable_x(%[git push origin chore/#{checksum} --tags])
dry_runnable_x(%[git checkout master])

if Opts["dry-run"]
  %x[git checkout -- maps/]
  %x[git checkout -- checksum]
  log("reset maps/ to HEAD")
end